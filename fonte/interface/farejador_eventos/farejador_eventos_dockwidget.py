# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FarejadorDockWidget
                                 A QGIS plugin
 Pequena aplicação que serve para selecionar eventos sismológicos e observar suas características.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Rocha de Lima, G. G;
        email                : gabrielgoes@usp.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program é um software livre; você pode redistribuir e/ou modificar  *
 *   sob os termos da GNU General Public License conforme publicado pela  *
 *   Free Software Foundation; seja a versão 2 da Licença ou  *
 *   (a seu critério) qualquer versão posterior.                            *
 *                                                                         *
 ***************************************************************************/
"""
import os
import io
import subprocess
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt

from qgis.core import QgsProject, QgsVectorLayer, QgsField, QgsFeature, QgsGeometry, QgsPointXY, QgsRendererCategory, QgsCategorizedSymbolRenderer, QgsSymbol
from qgis.PyQt.QtCore import QVariant
from qgis.PyQt import QtCore, QtWidgets

from obspy import read, UTCDateTime
from PIL import Image, ImageDraw

from farejdor_eventos.farejador_eventos_dockwidget_base import Ui_FarejadorDockWidgetBase


PROJ_DIR = os.environ['HOME'] + "/projetos/ClassificadorSismologico/"


class FarejadorDockWidget(QtWidgets.QDockWidget, Ui_FarejadorDockWidgetBase):
    closingPlugin = QtCore.pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(FarejadorDockWidget, self).__init__(parent)
        self.df = pd.read_csv(f"{PROJ_DIR}arquivos/resultados/analisado_nc.csv")
        self.layer= None
        self.setupUi(self)
        self.initUI()
        self.createLayerFromDF()

    def initUI(self):
        self.eventSelector = self.findChild(QtWidgets.QComboBox, 'eventSelector')
        self.networkSelector = self.findChild(QtWidgets.QComboBox, 'networkSelector')
        self.stationSelector = self.findChild(QtWidgets.QComboBox, 'stationSelector')
        self.numb_Eventos = self.findChild(QtWidgets.QLabel, 'numb_Eventos')
        self.nb_picksText = self.findChild(QtWidgets.QLabel, 'nb_picksText')
        self.ev_predText = self.findChild(QtWidgets.QLabel, 'ev_predText')
        self.probNatText = self.findChild(QtWidgets.QLabel, 'probNatText')
        self.distanceText = self.findChild(QtWidgets.QLabel, 'distanceText')
        self.stPredText = self.findChild(QtWidgets.QLabel, 'stPredText')
        self.stProbText = self.findChild(QtWidgets.QLabel, 'stProbText')
        self.mseedText = self.findChild(QtWidgets.QLabel, 'mseedText')
        self.eventText = self.findChild(QtWidgets.QLabel, 'eventText')
        self.loadButton = self.findChild(QtWidgets.QPushButton, 'loadButton')
        self.spectreButton = self.findChild(QtWidgets.QPushButton, 'spectreButton')
        self.autoselectCheckbox = self.findChild(QtWidgets.QCheckBox, 'autoselectCheckbox')
        self.invertCheckbox = self.findChild(QtWidgets.QCheckBox, 'invertCheckbox')
        self.logCheckbox = self.findChild(QtWidgets.QCheckBox, 'logCheckbox')

        self.loadButton.clicked.connect(self.loadMseed)
        self.spectreButton.clicked.connect(self.loadSpectre)
        self.autoselectCheckbox.stateChanged.connect(self.updateAutoSelection)
        self.invertCheckbox.stateChanged.connect(self.updateEventSelector)
        self.logCheckbox.stateChanged.connect(self.updateLog)

        self.eventSelector.currentIndexChanged.connect(self.updateNetworkAndStationSelectors)
        self.networkSelector.currentIndexChanged.connect(self.updateStationSelector)
        self.eventSelector.currentIndexChanged.connect(self.logEvent)

        ev = self.get_EventsSorted()
        self.eventos_cre, self.eventos_dec, self.numb_eventos = ev

        self.updateEventSelector(QtCore.Qt.Checked)
        self.updateNetworkAndStationSelectors()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def createLayerFromDF(self):
        layer = QgsVectorLayer("Point?crs=EPSG:4326", "Eventos Sismológicos", "memory")
        provider = layer.dataProvider()
        provider.addAttributes([
            QgsField("Event", QVariant.String),
            QgsField("Station", QVariant.String),
            QgsField("Network", QVariant.String),
            QgsField("Cat", QVariant.String),
            QgsField("SNR_P", QVariant.Double),
            QgsField("Região Origem", QVariant.String),
            QgsField("Start Time", QVariant.String),
            QgsField("End Time", QVariant.String),
            QgsField("Pick Time", QVariant.String),
            QgsField("Origem Latitude", QVariant.Double),
            QgsField("Origem Longitude", QVariant.Double),
            QgsField("Distance", QVariant.Double),
            QgsField("Num_Estacoes", QVariant.Int),
            QgsField("Event Prob_Nat", QVariant.Double),
            QgsField("Pick Prob_Nat", QVariant.Double),
            QgsField("Event Pred_final", QVariant.String),
            QgsField("Pick Pred_final", QVariant.String),
        ])
        layer.updateFields()

        for _, row in self.df.iterrows():
            feature = QgsFeature()
            point = QgsPointXY(row['Origem Longitude'], row['Origem Latitude'])
            feature.setGeometry(QgsGeometry.fromPointXY(point))
            feature.setAttributes([
                row['Event'],
                row['Station'],
                row['Network'],
                row['Cat'],
                row['SNR_P'],
                row['Região Origem'],
                row['Start Time'],
                row['End Time'],
                row['Pick Time'],
                row['Origem Latitude'],
                row['Origem Longitude'],
                row['Distance'],
                row['Num_Estacoes'],
                row['Event Prob_Nat'],
                row['Pick Prob_Nat'],
                row['Event Pred_final'],
                row['Pick Pred_final'],
            ])
            provider.addFeature(feature)

        layer.updateExtents()
        self.layer = layer
        QgsProject.instance().addMapLayer(self.layer)

    def updateAutoSelection(self, state):
        if state == QtCore.Qt.Checked:
            self.eventSelector.currentIndexChanged.connect(self.loadMseed)
            self.networkSelector.currentIndexChanged.connect(self.loadMseed)
            self.stationSelector.currentIndexChanged.connect(self.loadMseed)
        else:
            self.eventSelector.currentIndexChanged.disconnect(self.loadMseed)
            self.networkSelector.currentIndexChanged.disconnect(self.loadMseed)
            self.stationSelector.currentIndexChanged.disconnect(self.loadMseed)

    def updateLog(self, state):
        if state == QtCore.Qt.Checked:
            self.eventSelector.currentIndexChanged.connect(self.logEvent)
        else:
            self.eventSelector.currentIndexChanged.disconnect(self.logEvent)

    def logEvent(self):
        selected_event = self.eventSelector.currentText()
        if selected_event:
            df_ = self.df.set_index(['Event', 'Station'])
            event_data = df_.loc[selected_event]
            self.event_data = event_data[[
                'Cat',
                'Error',
                'Compo',
                'Pick',
                'SNR_P',
                'Região Origem',
                'Start Time',
                'End Time',
                'Pick Time',
                'Origem Latitude',
                'Origem Longitude',
                'Network',
                'Distance',
                'Num_Estacoes',
                'Event Prob_Nat',
                'Pick Prob_Nat',
            ]]
            print(f'Evento: {selected_event}')
            print(event_data[[
                'Origem Latitude',
                'Origem Longitude',
                'Network',
                'SNR_P',
                'SNR_P_Q2'
            ]])
            print('_____________________________________________________\n')

            if self.layer is None:
                print('Camada não definida.')
                return
            symbol_selected = QgsSymbol.defaultSymbol(self.layer.geometryType())
            symbol_selected.setColor(QtCore.Qt.red)
            symbol_selected.setSize(10)
            symbol_default = QgsSymbol.defaultSymbol(self.layer.geometryType())
            symbol_default.setColor(QtCore.Qt.blue)
            symbol_default.setSize(5)

            categories = []
            for f in self.layer.getFeatures():
                if f['Event'] == selected_event:
                    categories.append(QgsRendererCategory(f['Event'], symbol_selected, f['Event']))
                else:
                    categories.append(QgsRendererCategory(f['Event'], symbol_default, f['Event']))

            renderer = QgsCategorizedSymbolRenderer("Event", categories)
            self.layer.setRenderer(renderer)
            self.layer.triggerRepaint()

    def get_EventsSorted(self):
        eventos = self.df['Event'].unique()
        numb_eventos = len(eventos)
        eventos_cre = sorted(
            eventos, key=lambda x: self.df.loc[
                self.df['Event'] == x,
                'Event Prob_Nat'
            ].iloc[0]
        )
        eventos_dec = eventos_cre[::-1]
        print(' ---------------- Eventos ordenados ---------------- ')
        print('_____________________________________________________')
        return eventos_cre, eventos_dec, numb_eventos

    def updateEventSelector(self, state):
        self.eventSelector.clear()
        if state == QtCore.Qt.Checked:
            self.eventSelector.addItems(self.eventos_dec)
        else:
            self.eventSelector.addItems(self.eventos_cre)
        if self.logCheckbox.isChecked():
            self.eventSelector.currentIndexChanged.connect(self.logEvent)

    def updateNetworkAndStationSelectors(self):
        self.networkSelector.clear()
        self.stationSelector.clear()
        selected_event = self.eventSelector.currentText()
        networks, stations = self.getNetworksAndStations(selected_event)
        self.networkSelector.addItems(sorted(networks))
        self.updateStationSelector()

    def updateStationSelector(self):
        self.stationSelector.clear()
        selected_event = self.eventSelector.currentText()
        selected_network = self.networkSelector.currentText()
        _, stations = self.getNetworksAndStations(selected_event, selected_network)
        self.stationSelector.addItems(sorted(stations))
        self.updateMseedAttributes()

    def getNetworksAndStations(self, selected_event, filter_network=None):
        picks = self.df[self.df['Event'] == selected_event]
        networks = set()
        stations = set()
        for _, pick in picks.iterrows():
            network = pick['Network']
            station = pick['Station']
            if filter_network and network != filter_network:
                continue
            networks.add(network)
            stations.add(station)
        return list(networks), list(stations)

    def updateMseedAttributes(self):
        ev = self.eventSelector.currentText()
        net = self.networkSelector.currentText()
        sta = self.stationSelector.currentText()
        mseed = f'{net}_{sta}_{ev}'
        self.mseedText.setText(f'Arquivo: {mseed}')
        self.eventText.setText(f'Evento: {ev}')
        self.mseed_file_path = os.path.join(
           PROJ_DIR, 'arquivos/mseed', ev, f'{net}_{sta}_{ev}.mseed'
        )

        filtered_df = self.df[(self.df['Event'] == ev) & (self.df['Station'] == sta)]
        nb_picks = self.df[(self.df['Event'] == ev)].shape[0]

        if not filtered_df.empty:
            ev_prediction = filtered_df['Event Pred_final'].iloc[0]
            ev_prob_nat = filtered_df['Event Prob_Nat'].iloc[0]
            ev_predito = filtered_df['Event Pred_final'].iloc[0]
            distancia = filtered_df['Distance'].iloc[0]
            st_prediction = filtered_df['Pick Pred_final'].iloc[0]
            st_prob_nat = filtered_df['Pick Prob_Nat'].iloc[0]
            rotulo = filtered_df['Cat'].iloc[0]
        else:
            ev_prediction = 'Evento não encontrado ou sem predição'
            ev_prob_nat = 'N/A'
            ev_predito = 'N/A'
            distancia = 'N/A'
            st_prediction = 'N/A'
            st_prob_nat = 'N/A'
            rotulo = 'N/A'

        rotulo = filtered_df['Cat'].iloc[0] if not filtered_df.empty else 'N/A'
        ev_prob_nat = filtered_df['Event Prob_Nat'].iloc[0] if not filtered_df.empty else 'N/A'
        ev_predito = filtered_df['Event Pred_final'].iloc[0] if not filtered_df.empty else 'N/A'
        label = 'Natural' if rotulo == 'earthquake' else 'Anthropogenic'

        self.nb_picksText.setText(f'#Picks: {nb_picks}')

        if ev_prediction != label:
            self.ev_predText.setStyleSheet('font-weight: bold; color: red')
        else:
            self.ev_predText.setStyleSheet('color: black')

        self.ev_predText.setText(f'Predição: {ev_predito}')
        self.probNatText.setText(f'Prob. Natural: {ev_prob_nat}')
        self.stPredText.setText(f'Predição (pick): {st_prediction}')
        self.stProbText.setText(f'Prob. Natural (pick): {st_prob_nat}')

        if distancia != 'N/A':
            try:
                self.distanceText.setText(f'Distância: {distancia:.1f} km')
            except Exception as e:
                self.distanceText.setText(f'Distância:{e}')
        else:
            self.distanceText.setText(f'Distância: {distancia}')

    def loadMseed(self):
        try:
            if not os.path.isfile(self.mseed_file_path):
                raise FileNotFoundError
            subprocess.Popen(['snuffler', self.mseed_file_path])
            print(f"Snuffler iniciado com {self.mseed_file_path}")
        except FileNotFoundError:
            print(f"Erro: Arquivo {self.mseed_file_path} não encontrado.")
        except Exception as e:
            print(f"Erro ao iniciar o Snuffler: {e}")

    def plot_waveform(self):
        plt.figure(figsize=(6, 2))
        ev = self.eventSelector.currentText()
        net = self.networkSelector.currentText()
        sta = self.stationSelector.currentText()
        mseed = f'{net}_{sta}_{ev}'
        st = read(f'{PROJ_DIR}arquivos/mseed/{ev}/{mseed}.mseed')
        tr = st[0].detrend('linear').filter('highpass', freq=2.0)
        t = np.arange(tr.stats.npts) * tr.stats.delta
        start = UTCDateTime(self.event_data.loc[sta]['Start Time'])
        pick = UTCDateTime(self.event_data.loc[sta]['Pick Time'])
        p_start = pick - start
        plt.axvspan(p_start, p_start + 3, alpha=0.5, label='S-Window', color='green')
        plt.plot(t, tr.data, c='k')
        plt.tight_layout()
        buf = io.BytesIO()
        plt.savefig(buf, format='png')
        plt.close()
        buf.seek(0)

        Img_waveform = Image.open(buf)
        return Img_waveform

    def loadSpectre(self):
        try:
            if not os.path.isfile(self.mseed_file_path):
                raise FileNotFoundError
            ev = self.eventSelector.currentText()
            net = self.networkSelector.currentText()
            sta = self.stationSelector.currentText()

            npy = f'{net}_{sta}_{ev}.npy'
            path = os.path.join(PROJ_DIR, 'arquivos/espectros', ev, npy)
            spectrogram = np.load(path, allow_pickle=True)
            spectrogram = np.moveaxis(spectrogram, 0, 2)

            freqs = list(range(1, 51))
            time = list(np.arange(0.5, 59.75, 0.25))
            psd_mat = np.array(spectrogram[:, :, 0])

            if psd_mat.shape != (len(time), len(freqs)):
                print(f"Dimensões do espectrograma inválidas: {psd_mat.shape}")
                return

            psd_mat_normalized = 255 * (psd_mat - psd_mat.min()) / (psd_mat.max() - psd_mat.min())
            psd_mat_normalized = psd_mat_normalized.astype(np.uint8)

            cmap = plt.get_cmap('viridis')
            color_img = cmap(psd_mat_normalized.T)
            color_img = (color_img[:, :, :3] * 255).astype(np.uint8)

            img_spectro = Image.fromarray(color_img)
            img_spectro = img_spectro.transpose(Image.FLIP_TOP_BOTTOM)

            img_waveform = self.plot_waveform()

            total_height = img_spectro.height + img_waveform.height
            combined_img = Image.new('RGB', (img_waveform.width, total_height))
            combined_img.paste(img_spectro, (0, 0))
            combined_img.paste(img_waveform, (0, img_spectro.height))

            draw = ImageDraw.Draw(combined_img)
            draw.text((255, 5), f'{ev}_{net}_{sta}', fill='white')
            prob = self.event_data.loc[sta]['Pick Prob_Nat']
            prob_e = self.event_data.loc[sta]['Event Prob_Nat']
            draw.text((255, 20), f'Pick: {prob}', fill='white')
            draw.text((310, 20), f'Event: {prob_e}', fill='white')

            combined_img.save(f'{PROJ_DIR}arquivos/figuras/espectros/{ev}_{net}_{sta}.png')
            combined_img.show()

            print(f"Spectrogram iniciado com {path}")
        except Exception as e:
            print(f"Erro ao iniciar o Espectrograma: {e}")
            if e == FileNotFoundError:
                print(f"Arquivo {path} não encontrado.")
