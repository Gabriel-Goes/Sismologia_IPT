# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FarejadorDockWidget
                                 A QGIS plugin
 Pequena aplicação que serve para selecionar eventos sismológicos e observar suas características.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Rocha de Lima, G. G;
        email                : gabrielgoes@usp.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program é um software livre; você pode redistribuir e/ou modificar  *
 *   sob os termos da GNU General Public License conforme publicado pela  *
 *   Free Software Foundation; seja a versão 2 da Licença ou  *
 *   (a seu critério) qualquer versão posterior.                            *
 *                                                                         *
 ***************************************************************************/
"""

# ------------------------------- IMPORTS ----------------------------------- #
import os
import io
import subprocess
import pandas as pd
import numpy as np
import logging
from matplotlib import pyplot as plt

from qgis.core import QgsProject
from qgis.core import QgsVectorLayer
from qgis.core import QgsField
from qgis.core import QgsFeature
from qgis.core import QgsGeometry
from qgis.core import QgsPointXY
from qgis.core import QgsRendererCategory
from qgis.core import QgsCategorizedSymbolRenderer
from qgis.core import QgsFeatureRequest
from qgis.core import QgsSymbol
from qgis.PyQt.QtCore import QVariant
from qgis.PyQt import QtCore, QtWidgets

from obspy import read, UTCDateTime
from PIL import Image, ImageDraw

from .farejadorsismo_dockwidget_base import Ui_FarejadorDockWidgetBase


# ----------------------------- CONSTANTES ---------------------------------- #
PROJ_DIR = os.path.expanduser("~/projetos/ClassificadorSismologico/")
FIGURE_DIR = os.path.join(PROJ_DIR, "arquivos/figuras/")
LOG_FILE = os.path.join(PROJ_DIR, "arquivos/registros/farejador.log")
CSV_FILE = os.path.join(PROJ_DIR, "arquivos/resultados/analisado_nc.csv")

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename=LOG_FILE
)

COLUMN_NAMES = [
    "Event", "Station", "Network",
    "Event Pred_final", "Pick Pred_final", "Event Prob_Nat", "Pick Prob_Nat",
    "Start Time", "End Time", "Pick Time",
    "Cat", "MLv", "SNR_P", "SNR_P_Q2", "Distance", "Distance_Q2",
    "Região Origem", "Num_Estacoes",
    "Origem Latitude", "Origem Longitude",
]


# -------------------------------- CLASSE ----------------------------------- #
class FarejadorDockWidget(QtWidgets.QDockWidget, Ui_FarejadorDockWidgetBase):
    closingPlugin = QtCore.pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(FarejadorDockWidget, self).__init__(parent)
        self.df = self.load_csv(CSV_FILE)
        self.layer = None
        self.setupUi(self)
        self.initUI()

    def load_csv(self, csv_file):
        try:
            return pd.read_csv(csv_file)
        except Exception as e:
            logging.error(f'Erro ao carregar {csv_file}: {e}')
            QtWidgets.QMessageBox.critical(
                    self, 'Erro', f'Erro ao carregar {csv_file}: {e}')
            return pd.DataFrame(columns=COLUMN_NAMES)

    def initUI(self):
        self.numb_Eventos = self.findChild(QtWidgets.QLabel, 'numb_Eventos')
        self.eventSelector = self.findChild(QtWidgets.QComboBox, 'eventSelector')
        self.networkSelector = self.findChild(QtWidgets.QComboBox, 'networkSelector')
        self.stationSelector = self.findChild(QtWidgets.QComboBox, 'stationSelector')
        self.nb_picksText = self.findChild(QtWidgets.QLabel, 'nb_picksText')
        self.ev_predText = self.findChild(QtWidgets.QLabel, 'ev_predText')
        self.probNatText = self.findChild(QtWidgets.QLabel, 'probNatText')
        self.distanceText = self.findChild(QtWidgets.QLabel, 'distanceText')
        self.stPredText = self.findChild(QtWidgets.QLabel, 'stPredText')
        self.stProbText = self.findChild(QtWidgets.QLabel, 'stProbText')
        self.mseedText = self.findChild(QtWidgets.QLabel, 'mseedText')
        self.eventText = self.findChild(QtWidgets.QLabel, 'eventText')
        self.loadButton = self.findChild(QtWidgets.QPushButton, 'loadButton')
        self.spectreButton = self.findChild(QtWidgets.QPushButton, 'spectreButton')
        self.autoselectCheckbox = self.findChild(QtWidgets.QCheckBox, 'autoselectCheckbox')
        self.logCheckbox = self.findChild(QtWidgets.QCheckBox, 'logCheckbox')
        self.invertCheckbox = self.findChild(QtWidgets.QCheckBox, 'invertCheckbox')

        self.labelOrdenarEventos = QtWidgets.QLabel(self)
        self.labelOrdenarEventos.setText('Ordenar Eventos por: ')

        self.filterLineEdit = QtWidgets.QLineEdit(self)
        self.filterLineEdit.setPlaceholderText('Digite para filtrar eventos')
        self.filterLineEdit.textChanged.connect(self.updateEventFilter)

        self.sortColumnComboBox = QtWidgets.QComboBox(self)
        self.sortColumnComboBox.addItems([
            'Event',
            'SNR_P_Q2',
            'Distance_Q2',
            'Event Prob_Nat',
            'MLv',
        ])
        self.sortColumnComboBox.currentIndexChanged.connect(self.get_EventsSorted)

        layout = self.findChild(QtWidgets.QVBoxLayout, 'verticalLayout')
        filter_sort_layout = QtWidgets.QHBoxLayout()
        filter_sort_layout.addWidget(self.labelOrdenarEventos)
        filter_sort_layout.addWidget(self.filterLineEdit)
        filter_sort_layout.addWidget(self.sortColumnComboBox)
        layout.insertWidget(0, self.filterLineEdit)
        self.get_EventsSorted()

        self.loadButton.clicked.connect(self.loadSnuffler)
        self.spectreButton.clicked.connect(self.loadSpectre)
        self.autoselectCheckbox.stateChanged.connect(self.updateAutoSelection)
        self.sortColumnComboBox.currentIndexChanged.connect(self.updateEventSelector)
        self.logCheckbox.stateChanged.connect(self.updateLog)

        self.eventSelector.currentIndexChanged.connect(self.updateNetworkAndStationSelectors)
        self.networkSelector.currentIndexChanged.connect(self.updateStationSelector)
        self.stationSelector.currentIndexChanged.connect(self.updateMseedAttributes)

        self.updateEventSelector(QtCore.Qt.Checked)
        self.updateNetworkAndStationSelectors()

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def updateEventFilter(self, text):
        filtered_events = [ev for ev in self.ev_dec if text.lower() in ev.lower()]
        self.eventSelector.clear()
        self.eventSelector.addItems(filtered_events)

    def createLayerFromDF(self):
        logging.info('Criando camada de eventos...')
        try:
            self.layer = QgsVectorLayer("Point?crs=EPSG:4326", "Eventos Sismológicos", "memory")
            provider = self.layer.dataProvider()
            provider.addAttributes([
                QgsField(name, QVariant.String) for name in COLUMN_NAMES
            ])
            self.layer.updateFields()
            logging.info('Camada de eventos criada com sucesso.')
        except Exception as e:
            logging.error(f'Erro ao criar camada sismológicos: {e}')

    def updateAutoSelection(self, state):
        if state == QtCore.Qt.Checked:
            self.eventSelector.currentIndexChanged.connect(self.loadSpectre)
        else:
            self.eventSelector.currentIndexChanged.disconnect(self.loadSpectre)

    def updateLog(self, state):
        if state == QtCore.Qt.Checked:
            logging.info('Log de eventos habilitado.')
            self.eventSelector.currentIndexChanged.connect(self.logEvent)
        else:
            logging.info('Log de eventos desabilitado.')
            self.eventSelector.currentIndexChanged.connect(self.logEvent)

    def logEvent(self):
        ev = self.eventSelector.currentText()
        sta = self.stationSelector.currentText()
        if self.layer is None:
            logging.warning('Camada não definida.')
            self.createLayerFromDF()
            return
        if ev in [f['Event'] for f in self.layer.getFeatures()]:
            logging.info(f'Evento {ev} presente na camada.')
            self.repaintLayer()
            self.feature = next(
                self.layer.getFeatures(
                    QgsFeatureRequest().setFilterExpression(
                        f'Event = \'{ev}\' AND Station = \'{sta}\''
                    )
                )
            )
            return
        try:
            self.addFeatureToLayer(ev, sta)
        except Exception as e:
            logging.error(f'Erro ao logar evento {ev}-{sta}: {e}')

    def addFeatureToLayer(self, ev, sta):
        logging.info(f'Evento {ev} selecionado')
        df_ = self.df.set_index(['Event', 'Station'])
        ev_data = df_.loc[ev]
        self.event_data = ev_data[[COLUMN_NAMES]]

        features = []
        provider = self.layer.dataProvider()
        for _, row in self.df.iterrows():
            if row['Event'] != ev:
                continue
            if any(f['Event'] == row['Event'] for f in features):
                logging.info(f'Feature de {row["Event"]} já existe na camada.')
                continue

            feature = QgsFeature()
            point = QgsPointXY(row['Origem Longitude'], row['Origem Latitude'])
            feature.setGeometry(QgsGeometry.fromPointXY(point))

    def repaintLayer(self):
        try:
            symbol_selected = QgsSymbol.defaultSymbol(self.layer.geometryType())
            symbol_selected.setSize(5)
            symbol_default = QgsSymbol.defaultSymbol(self.layer.geometryType())
            symbol_default.setSize(2.5)

            categories = []
            for f in self.layer.getFeatures():
                if f['Event'] == self.eventSelector.currentText():
                    if f['Event Pred_final'] == 'Natural':
                        symbol_clone = symbol_selected.clone()
                        symbol_clone.setColor(QtCore.Qt.blue)
                        categories.append(QgsRendererCategory(f['Event'], symbol_clone, f['Event']))
                    else:
                        symbol_clone = symbol_selected.clone()
                        symbol_clone.setColor(QtCore.Qt.red)
                        categories.append(QgsRendererCategory(f['Event'], symbol_clone, f['Event']))
                else:
                    if f['Event Pred_final'] == 'Natural':
                        symbol_clone = symbol_default.clone()
                        symbol_clone.setColor(QtCore.Qt.blue)
                        categories.append(QgsRendererCategory(f['Event'], symbol_clone, f['Event']))
                    else:
                        symbol_clone = symbol_default.clone()
                        symbol_clone.setColor(QtCore.Qt.red)
                        categories.append(QgsRendererCategory(f['Event'], symbol_clone, f['Event']))

            renderer = QgsCategorizedSymbolRenderer("Event", categories)
            self.layer.setRenderer(None)
            self.layer.setRenderer(renderer)
            self.layer.triggerRepaint()
            logging.info('Layer Trigger Repaint.')
        except Exception as e:
            if self.layer is None:
                logging.warning('Camada não definida.')
                return
            logging.error(e)

    def get_EventsSorted(self):
        evs = self.df['Event'].unique()
        self.numb_Eventos.setText(f'Número de Eventos: {len(evs)}')
        sort_column = self.sortColumnComboBox.currentText()
        if sort_column == 'Event':
            self.ev_cre = sorted(evs)
        else:
            self.ev_cre = sorted(
                evs, key=lambda x: self.df.loc[
                    self.df['Event'] == x, sort_column
                ].iloc[0]
            )
        self.ev_dec = self.ev_cre[::-1]
        self.updateEventSelector(self.invertCheckbox.checkState())

    def updateEventSelector(self, state):
        self.eventSelector.clear()
        if state == QtCore.Qt.Checked:
            self.eventSelector.addItems(self.ev_dec)
        else:
            self.eventSelector.addItems(self.ev_cre)
        if self.logCheckbox.isChecked():
            self.eventSelector.currentIndexChanged.connect(self.logEvent)

    def updateNetworkAndStationSelectors(self):
        self.networkSelector.clear()
        self.stationSelector.clear()
        self.selected_event = self.eventSelector.currentText()
        networks, stations = self.getNetworksAndStations(self.selected_event)
        self.networkSelector.addItems(sorted(networks))
        self.updateStationSelector()

    def updateStationSelector(self):
        self.stationSelector.clear()
        selected_event = self.eventSelector.currentText()
        selected_network = self.networkSelector.currentText()
        _, stations = self.getNetworksAndStations(selected_event, selected_network)
        self.stationSelector.addItems(sorted(stations))
        self.updateMseedAttributes()

    def getNetworksAndStations(self, selected_event, filter_network=None):
        picks = self.df[self.df['Event'] == selected_event]
        networks = set()
        stations = set()
        for _, pick in picks.iterrows():
            network = pick['Network']
            station = pick['Station']
            if filter_network and network != filter_network:
                continue
            networks.add(network)
            stations.add(station)
        return list(networks), list(stations)

    def updateMseedAttributes(self):
        ev = self.eventSelector.currentText()
        net = self.networkSelector.currentText()
        sta = self.stationSelector.currentText()
        mseed = f'{net}_{sta}_{ev}'
        self.mseedText.setText(f'Arquivo: {mseed}')
        self.eventText.setText(f'Evento: {ev}')
        self.mseed_file_path = os.path.join(
           PROJ_DIR, 'arquivos/mseed', ev, f'{net}_{sta}_{ev}.mseed'
        )

        filtered_df = self.df[(self.df['Event'] == ev) & (self.df['Station'] == sta)]
        nb_picks = self.df[(self.df['Event'] == ev)].shape[0]

        if not filtered_df.empty:
            ev_prediction = filtered_df['Event Pred_final'].iloc[0]
            ev_prob_nat = filtered_df['Event Prob_Nat'].iloc[0]
            ev_predito = filtered_df['Event Pred_final'].iloc[0]
            distancia = filtered_df['Distance'].iloc[0]
            st_prediction = filtered_df['Pick Pred_final'].iloc[0]
            st_prob_nat = filtered_df['Pick Prob_Nat'].iloc[0]
            rotulo = filtered_df['Cat'].iloc[0]
        else:
            ev_prediction = 'Evento não encontrado ou sem predição'
            ev_prob_nat = 'N/A'
            ev_predito = 'N/A'
            distancia = 'N/A'
            st_prediction = 'N/A'
            st_prob_nat = 'N/A'
            rotulo = 'N/A'

        rotulo = filtered_df['Cat'].iloc[0] if not filtered_df.empty else 'N/A'
        ev_prob_nat = filtered_df['Event Prob_Nat'].iloc[0] if not filtered_df.empty else 'N/A'
        ev_predito = filtered_df['Event Pred_final'].iloc[0] if not filtered_df.empty else 'N/A'
        label = 'Natural' if rotulo == 'earthquake' else 'Anthropogenic'

        self.nb_picksText.setText(f'#Picks: {nb_picks}')

        if ev_prediction != label:
            self.ev_predText.setStyleSheet('font-weight: bold; color: red')
        else:
            self.ev_predText.setStyleSheet('color: black')

        self.ev_predText.setText(f'Predição: {ev_predito}')
        self.probNatText.setText(f'Prob. Natural: {ev_prob_nat}')
        self.stPredText.setText(f'Predição (pick): {st_prediction}')
        self.stProbText.setText(f'Prob. Natural (pick): {st_prob_nat}')

        if distancia != 'N/A':
            try:
                self.distanceText.setText(f'Distância: {distancia:.1f} km')
            except Exception as e:
                self.distanceText.setText(f'Distância:{e}')
        else:
            self.distanceText.setText(f'Distância: {distancia}')

    def loadSnuffler(self):
        try:
            if not os.path.isfile(self.mseed_file_path):
                raise FileNotFoundError
            subprocess.Popen(['snuffler', self.mseed_file_path])
            print(f"Snuffler iniciado com {self.mseed_file_path}")
        except FileNotFoundError:
            print(f"Erro: Arquivo {self.mseed_file_path} não encontrado.")
        except Exception as e:
            print(f"Erro ao iniciar o Snuffler: {e}")

    def plot_waveform(self):
        plt.figure(figsize=(6, 2))
        ev = self.eventSelector.currentText()
        net = self.networkSelector.currentText()
        sta = self.stationSelector.currentText()
        mseed = f'{net}_{sta}_{ev}'
        st = read(f'{PROJ_DIR}arquivos/mseed/{ev}/{mseed}.mseed')
        tr = st[0].detrend('linear').filter('highpass', freq=2.0)
        t = np.arange(tr.stats.npts) * tr.stats.delta
        pick = UTCDateTime(self.feature['Pick Time'])
        start = UTCDateTime(self.feature['Start Time'])
        p_start = pick - start
        plt.axvspan(p_start, p_start + 3, alpha=0.5, label='S-Window', color='green')
        plt.plot(t, tr.data, c='k')
        plt.tight_layout()
        buf = io.BytesIO()
        plt.savefig(buf, format='png')
        plt.close()
        buf.seek(0)
        Img_waveform = Image.open(buf)
        return Img_waveform

    def loadSpectre(self):
        try:
            if not os.path.isfile(self.mseed_file_path):
                raise FileNotFoundError
            ev = self.eventSelector.currentText()
            net = self.networkSelector.currentText()
            sta = self.stationSelector.currentText()

            npy = f'{net}_{sta}_{ev}.npy'
            path = os.path.join(PROJ_DIR, 'arquivos/espectros', ev, npy)
            spectrogram = np.load(path, allow_pickle=True)
            spectrogram = np.moveaxis(spectrogram, 0, 2)

            freqs = list(range(1, 51))
            time = list(np.arange(0.5, 59.75, 0.25))
            psd_mat = np.array(spectrogram[:, :, 0])

            if psd_mat.shape != (len(time), len(freqs)):
                logging.error(f"Dimensões inválidas: {psd_mat.shape}")
                print(f"Dimensões inválidas: {psd_mat.shape}")
                return

            psd_mat_normalized = (
                psd_mat - psd_mat.min()) / (psd_mat.max() - psd_mat.min())
            psd_mat_normalized = (psd_mat_normalized * 255).astype(np.uint8)

            cmap = plt.get_cmap('viridis')
            color_img = cmap(psd_mat_normalized.T)
            color_img = (color_img[:, :, :3] * 255).astype(np.uint8)

            img_spectro = Image.fromarray(color_img)
            img_spectro = img_spectro.transpose(Image.FLIP_TOP_BOTTOM)
            try:
                img_waveform = self.plot_waveform()
            except Exception as e:
                print(f"Erro ao plotar waveform: {e}")
                logging.error(f"img_waveform Error: {e}")
                return

            total_height = img_spectro.height + img_waveform.height
            combined_img = Image.new('RGB', (img_waveform.width, total_height))
            combined_img.paste(img_spectro, (0, 0))
            combined_img.paste(img_waveform, (0, img_spectro.height))

            draw = ImageDraw.Draw(combined_img)
            draw.text((255, 5), f'{ev}_{net}_{sta}', fill='white')
            prob = self.feature['Pick Prob_Nat']
            prob_e = self.feature['Event Prob_Nat']
            distance = self.feature['Distance']
            snrp_q = self.feature['SNR_P_Q2']
            snrp = self.feature['SNR_P']
            draw.text((255, 20), f'Pick: {prob}', fill='white')
            draw.text((310, 20), f'Event: {prob_e}', fill='white')
            draw.text((255, 35), f'Distance: {distance:.1f} km', fill='white')
            draw.text((355, 35), f'SNR: {snrp:.1f}', fill='white')
            draw.text((355, 45), f'SNR Q2: {snrp_q:.1f}', fill='white')

            combined_img.save(f'{FIGURE_DIR}/espectros/{ev}_{net}_{sta}.png')
            combined_img.show()
            logging.info(f"Spectrogram iniciado com {path}")
            print(f"Spectrogram iniciado com {path}")
        except Exception as e:
            print(e)
            logging.error(f"Erro ao iniciar o Espectrograma: {e}")
            print(f"Erro ao iniciar o Espectrograma: {e}")
            if e == FileNotFoundError:
                logging.error(f"FileNootFoundError: {e}")
                print(f"Arquivo {path} não encontrado.")
