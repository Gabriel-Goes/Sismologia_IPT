# -*- coding: utf-8 -*-
"""
/***************************************************************************
 FarejadorDockWidget
                                 A QGIS plugin
 Pequena aplicação que serve para selecionar eventos sismológicos e observar
 suas características.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-05-29
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Rocha de Lima, G. G;
        email                : gabrielgoes@usp.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program é um software livre; você pode redistribuir e/ou modificar  *
 *   sob os termos da GNU General Public License conforme publicado pela  *
 *   Free Software Foundation; seja a versão 2 da Licença ou  *
 *   (a seu critério) qualquer versão posterior.                            *
 *                                                                         *
 ***************************************************************************/
"""

# ------------------------------- IMPORTS ----------------------------------- #
import os
import io
import subprocess
import pandas as pd
import numpy as np
import logging
from matplotlib import pyplot as plt
from PIL import Image, ImageDraw

from qgis.core import QgsProject
from qgis.core import QgsVectorLayer
from qgis.core import QgsField
from qgis.core import QgsFeature
from qgis.core import QgsGeometry
from qgis.core import QgsPointXY
from qgis.core import QgsCategorizedSymbolRenderer
from qgis.core import QgsSingleSymbolRenderer
from qgis.core import QgsFeatureRequest
from qgis.core import QgsSymbol
from qgis.core import QgsRectangle
from qgis.core import QgsLineSymbol
from qgis.core import QgsSimpleMarkerSymbolLayer
from qgis.core import QgsMarkerSymbol
from qgis.PyQt.QtGui import QColor
from qgis.PyQt.QtCore import QVariant
from qgis.utils import iface
from qgis.PyQt import QtCore, QtWidgets

from obspy import read, UTCDateTime

from .farejadorsismo_dockwidget_base import Ui_FarejadorDockWidgetBase


# ----------------------------- CONSTANTES ---------------------------------- #
PLUGIN_DIR = os.path.dirname(os.path.abspath(__file__))
PROJ_DIR = os.path.abspath(os.path.join(PLUGIN_DIR, os.pardir, os.pardir, os.pardir))
FILES_DIR = os.path.join(PROJ_DIR, "arquivos")
FIGURE_DIR = os.path.join(FILES_DIR, "figuras")
LOG_FILE = os.path.join(FILES_DIR, "registros", "farejador.log")
CSV_DIR = os.path.join(FILES_DIR, "resultados", "analisado")
CSV_FILE = os.path.join(CSV_DIR, "nc_analisado_final.csv")

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    filename=LOG_FILE
)


# -------------------------------- CLASSE ----------------------------------- #
class FarejadorDockWidget(QtWidgets.QDockWidget, Ui_FarejadorDockWidgetBase):
    closingPlugin = QtCore.pyqtSignal()

    def __init__(self, parent=None):
        super(FarejadorDockWidget, self).__init__(parent)
        self.eventos = self.csv2dict(CSV_FILE)
        self.createLayerFromDF()
        self.setupUi(self)
        self.initUI()
        self.loadCSVFiles()
        self.updateUI()

    def loadCSVFiles(self):
        self.csvSelector = self.findChild(QtWidgets.QComboBox, 'csvSelector')
        csv_files = self.list_files(CSV_DIR)
        self.csvSelector.addItems(csv_files)
        self.csvSelector.currentIndexChanged.connect(self.onCSVSelected)
        self.onCSVSelected()

    def onCSVSelected(self):
        selected_csv = self.csvSelector.currentText()
        csv_path = os.path.join(CSV_DIR, selected_csv)
        self.eventos = self.csv2dict(csv_path)
        if self.eventos is None:
            self.eventos = {}
        self.createLayerFromDF()
        self.get_EventsSorted()
        self.updateUI()

    def csv2dict(self, csv_file):
        try:
            self.df = pd.read_csv(csv_file)
            logging.info(f'{csv_file} carregado com sucesso.')
        except Exception as e:
            logging.error(f'Erro ao carregar {csv_file}: {e}')
            QtWidgets.QMessageBox.critical(
                self, 'Erro', f'Erro ao carregar {csv_file}: {e}'
            )
            return None
        eventos = {}
        for ev, picks in self.df.groupby('Event'):
            if ev not in eventos:
                eventos[ev] = picks.reset_index().set_index('Station')

        return eventos

    def createLayerFromDF(self):
        try:
            if self.df.empty:
                raise ValueError('DataFrame vazio.')

            required_columns = [
                'Origem Longitude', 'Origem Latitude', 'Event',
                'Longitude', 'Latitude', 'Station', 'Network'
            ]
            for col in required_columns:
                if col not in self.df.columns:
                    raise ValueError(f'Coluna {col} não encontrada.')

            # Verificar e usar camada de eventos existente
            event_layer_name = 'Eventos'
            event_layer = QgsProject.instance().mapLayersByName(event_layer_name)
            if event_layer:
                self.layer = event_layer[0]  # Usar a camada existente
                logging.info(f'Camada existente "{event_layer_name}" usada.')
            else:
                # Criar nova camada de eventos
                event_layer = QgsVectorLayer('Point?crs=EPSG:4326', event_layer_name, 'memory')
                event_provider = event_layer.dataProvider()
                event_provider.addAttributes([
                    QgsField('EventID', QVariant.String),
                    QgsField('Origem Longitude', QVariant.Double),
                    QgsField('Origem Latitude', QVariant.Double)
                ])
                event_layer.updateFields()

                event_features = []
                for event_id, group in self.df.groupby('Event'):
                    event_row = group.iloc[0]

                    # Validar os tipos dos valores
                    try:
                        origem_longitude = float(event_row['Origem Longitude'])
                        origem_latitude = float(event_row['Origem Latitude'])
                    except ValueError:
                        logging.error(f"Valores inválidos para EventID {event_id}")
                        continue

                    feature = QgsFeature()
                    event_point = QgsPointXY(origem_longitude, origem_latitude)
                    feature.setGeometry(QgsGeometry.fromPointXY(event_point))
                    feature.setAttributes([event_id, origem_longitude, origem_latitude])
                    event_features.append(feature)

                event_provider.addFeatures(event_features)
                event_layer.updateExtents()
                QgsProject.instance().addMapLayer(event_layer)
                self.layer = event_layer  # Salvar a camada recém-criada
                logging.info(f'Camada de eventos "{event_layer_name}" criada com sucesso.')

            # Verificar e usar camada de estações existente
            station_layer_name = 'Estacoes'
            station_layer = QgsProject.instance().mapLayersByName(station_layer_name)
            if station_layer:
                self.station_layer = station_layer[0]  # Usar a camada existente
                logging.info(f'Camada existente "{station_layer_name}" usada.')
            else:
                # Criar nova camada de estações
                station_layer = QgsVectorLayer('Point?crs=EPSG:4326', station_layer_name, 'memory')
                station_provider = station_layer.dataProvider()
                station_provider.addAttributes([
                    QgsField('Station', QVariant.String),
                    QgsField('Network', QVariant.String),
                    QgsField('Longitude', QVariant.Double),
                    QgsField('Latitude', QVariant.Double),
                    QgsField('EventID', QVariant.String)
                ])
                station_layer.updateFields()

                station_features = []
                for _, row in self.df.iterrows():
                    # Validar os tipos dos valores
                    try:
                        longitude = float(row['Longitude'])
                        latitude = float(row['Latitude'])
                    except ValueError:
                        logging.error(f"Valores inválidos para a estação {row['Station']}")
                        continue

                    feature = QgsFeature()
                    station_point = QgsPointXY(longitude, latitude)
                    feature.setGeometry(QgsGeometry.fromPointXY(station_point))
                    feature.setAttributes([row['Station'], row['Network'], longitude, latitude, row['Event']])
                    station_features.append(feature)

                station_provider.addFeatures(station_features)
                station_layer.updateExtents()
                QgsProject.instance().addMapLayer(station_layer)
                self.station_layer = station_layer  # Salvar a camada recém-criada
                logging.info(f'Camada de estações "{station_layer_name}" criada com sucesso.')

            # Estilizando as camadas (se necessário)
            self.setEventStyle(self.layer)
            self.setStationStyle(self.station_layer)

        except (KeyError, ValueError) as e:
            logging.error(f'Erro ao criar camadas: {e}')
            QtWidgets.QMessageBox.critical(
                self, 'Erro', f'Erro ao criar camadas: {str(e)}'
            )

        except Exception as e:
            logging.error(f'Erro ao criar camadas: {e}')
            QtWidgets.QMessageBox.critical(
                self, 'Erro', f'Erro ao criar camadas: {str(e)}'
            )

    def setEventStyle(self, layer):
        event_symbol = QgsSymbol.defaultSymbol(layer.geometryType())
        event_symbol.setColor(QColor("blue"))  # Cor azul para eventos
        event_symbol.setSize(4)  # Tamanho do símbolo
        renderer = QgsSingleSymbolRenderer(event_symbol)
        layer.setRenderer(renderer)
        layer.triggerRepaint()

    def setStationStyle(self, layer):
        station_symbol = QgsMarkerSymbol()
        triangle_layer = QgsSimpleMarkerSymbolLayer()
        triangle_layer.setShape(QgsSimpleMarkerSymbolLayer.Triangle)
        triangle_layer.setColor(QColor('red'))
        triangle_layer.setSize(3)
        station_symbol.changeSymbolLayer(0, triangle_layer)
        renderer = QgsSingleSymbolRenderer(station_symbol)
        layer.setRenderer(renderer)
        layer.triggerRepaint()

    def updateUI(self):
        self.updateEventSelector(QtCore.Qt.Checked)
        self.updateNetworkAndStationSelectors()

    def initUI(self):
        self.numb_Ev = self.findChild(QtWidgets.QLabel, 'numb_Eventos')
        self.numb_Ev.setText(f"Total de Eventos: {len(self.eventos.keys())}")
        self.eventSelector = self.findChild(QtWidgets.QComboBox, 'eventSelector')
        self.networkSelector = self.findChild(QtWidgets.QComboBox, 'networkSelector')
        self.stationSelector = self.findChild(QtWidgets.QComboBox, 'stationSelector')
        self.nb_picksText = self.findChild(QtWidgets.QLabel, 'nb_picksText')
        self.ev_predText = self.findChild(QtWidgets.QLabel, 'ev_predText')
        self.probNatText = self.findChild(QtWidgets.QLabel, 'probNatText')
        self.distanceText = self.findChild(QtWidgets.QLabel, 'distanceText')
        self.stPredText = self.findChild(QtWidgets.QLabel, 'stPredText')
        self.stProbText = self.findChild(QtWidgets.QLabel, 'stProbText')
        self.mseedText = self.findChild(QtWidgets.QLineEdit, 'mseedText')
        self.eventText = self.findChild(QtWidgets.QLabel, 'eventText')
        self.loadButton = self.findChild(QtWidgets.QPushButton, 'loadButton')
        self.spectreButton = self.findChild(QtWidgets.QPushButton, 'spectreButton')
        self.autoselectCheckbox = self.findChild(QtWidgets.QCheckBox, 'autoselectCheckbox')
        self.logCheckbox = self.findChild(QtWidgets.QCheckBox, 'logCheckbox')
        self.invertCheckbox = self.findChild(QtWidgets.QCheckBox, 'invertCheckbox')

        self.filterLineEdit = QtWidgets.QLineEdit(self)
        self.filterLineEdit.setPlaceholderText('Digite para filtrar eventos')
        self.filterLineEdit.textChanged.connect(self.updateEventFilter)

        self.labelOrdenarEventos = QtWidgets.QLabel(self)
        self.labelOrdenarEventos.setText('Ordenar Eventos por: ')

        self.sortColumnComboBox = QtWidgets.QComboBox(self)
        self.sortColumnComboBox.addItems([
            'Hora',
            'Event Prob_Nat',
            'MLv',
            'Num_Estacoes',
            'Pick Prob_Nat',
            'Distance_Q2',
            'SNR_P_Q2',
            'Pick Prob_Nat_std',
            'Distance_std',
            'SNRP_std',
            'CFT_std',
        ])
        self.sortColumnComboBox.currentIndexChanged.connect(self.get_EventsSorted)

        layout = self.findChild(QtWidgets.QVBoxLayout, 'verticalLayout')
        filter_sort_layout = QtWidgets.QHBoxLayout()
        filter_sort_layout.addWidget(self.labelOrdenarEventos)
        filter_sort_layout.addWidget(self.filterLineEdit)
        filter_sort_layout.addWidget(self.sortColumnComboBox)
        layout.insertWidget(0, self.filterLineEdit)
        self.get_EventsSorted()

        self.loadButton.clicked.connect(self.loadSnuffler)
        self.spectreButton.clicked.connect(self.loadSpectre)
        self.autoselectCheckbox.stateChanged.connect(self.updateAutoSelection)
        self.sortColumnComboBox.currentIndexChanged.connect(self.updateEventSelector)
        self.logCheckbox.stateChanged.connect(self.updateLog)
        self.invertCheckbox.stateChanged.connect(self.updateEventSelector)

        self.eventSelector.currentIndexChanged.connect(self.updateNetworkAndStationSelectors)
        self.networkSelector.currentIndexChanged.connect(self.updateStationSelector)
        self.stationSelector.currentIndexChanged.connect(self.updateMseedAttributes)

        logging.info('Interface iniciada...')

    def get_EventsSorted(self):
        sort_column = self.sortColumnComboBox.currentText()
        list_ev = list(self.eventos.keys())
        if sort_column == 'Event':
            logging.info('Ordenando eventos por "Evento".')
            self.ev_cre = sorted(list_ev)
        else:
            df = self.df.dropna(subset=[sort_column])
            logging.info(f'Ordenando eventos por {sort_column}.')
            self.ev_cre = sorted(
                df['Event'].unique(), key=lambda x: df.loc[
                    df['Event'] == x, sort_column
                ].iloc[0]
            )
        self.ev_dec = self.ev_cre[::-1]

    def getNetworksAndStations(self, filter_by_net=True):
        ev = self.eventSelector.currentText()
        net = self.networkSelector.currentText()
        picks = self.df[self.df['Event'] == ev]
        nets = set()
        stas = set()
        filter_net = net if filter_by_net else None
        for _, pick in picks.iterrows():
            net = pick['Network']
            sta = pick['Station']
            if filter_by_net and net != filter_net:
                continue
            nets.add(net)
            stas.add(sta)
        return nets, stas

    def updateNetworkAndStationSelectors(self):
        logging.info('\n #### Atualizando seletores #### \n')
        try:
            self.networkSelector.clear()
            self.stationSelector.clear()
            nets, stas = self.getNetworksAndStations(False)
            logging.info(f'{len(stas)} picks por {len(nets)} redes adquiridos.')
            self.networkSelector.addItems(sorted(nets))
            self.updateStationSelector()
            logging.info(f'Seletores atualizados: {self.eventSelector.currentText()}.')
        except Exception as e:
            logging.error(f'Erro ao atualizar seletores: {e}')

    def updateEventSelector(self, state):
        self.eventSelector.clear()
        if state == QtCore.Qt.Checked:
            self.eventSelector.addItems(self.ev_dec)
        else:
            self.eventSelector.addItems(self.ev_cre)
        if self.logCheckbox.isChecked():
            self.eventSelector.currentIndexChanged.connect(self.logEvent)

    def updateStationSelector(self):
        self.stationSelector.clear()
        nets, stas = self.getNetworksAndStations()
        self.stationSelector.addItems(sorted(stas))
        self.updateMseedAttributes()

    def updateEventFilter(self, text):
        filtered_events = [ev for ev in self.ev_dec if text.lower() in ev.lower()]
        self.eventSelector.clear()
        self.eventSelector.addItems(filtered_events)

    def updateAutoSelection(self, state):
        if state == QtCore.Qt.Checked:
            self.eventSelector.currentIndexChanged.connect(self.loadSpectre)
        else:
            self.eventSelector.currentIndexChanged.disconnect(self.loadSpectre)

    def updateLog(self, state):
        if state == QtCore.Qt.Checked:
            logging.info('Log de eventos habilitado.')
            self.eventSelector.currentIndexChanged.connect(self.logEvent)
        else:
            logging.info('Log de eventos desabilitado.')
            self.eventSelector.currentIndexChanged.disconnect(self.logEvent)

    def updateInvert(self, state):
        if state == QtCore.Qt.Checked:
            self.eventSelector.clear()
            self.eventSelector.addItems(self.ev_dec)
        else:
            self.eventSelector.clear()
            self.eventSelector.addItems(self.ev_cre)

    def logEvent(self):
        ev = self.eventSelector.currentText()
        logging.info(f'Evento {ev} selecionado')
        if self.layer is None:
            logging.warning('Camada não definida.')
            self.createLayerFromDF()
            return
        request = QgsFeatureRequest().setFilterExpression(f"Event = '{ev}'")
        features = self.layer.getFeatures(request)
        if any(features):
            logging.info(f'Evento {ev} presente na camada.')
            self.repaintLayer()
        else:
            logging.info(f'Evento {ev} não presente na camada.')
            self.addFeatureToLayer()

    def addFeatureToLayer(self):
        ev = self.eventSelector.currentText()
        logging.info(f'Adicionando {ev} à camada...')
        try:
            self.ev_data = self.df[self.df.Event == ev]
            features = []
            provider = self.layer.dataProvider()
            for _, row in self.ev_data.iterrows():
                feature = QgsFeature()
                point = QgsPointXY(row['Origem Longitude'], row['Origem Latitude'])
                feature.setGeometry(QgsGeometry.fromPointXY(point))
                feature.setAttributes([row[col] for col in self.df.columns])
                features.append(feature)
                logging.info(f'Pick {row.Station} adicionado.')
            provider.addFeatures(features)
            self.repaintLayer()
            self.layer.updateExtents()
            logging.info(f'Evento {ev} adicionado à camada.')
        except Exception as e:
            logging.error(f'Erro ao adicionar {self.ev_data.head()}:\n {e}')
        try:
            QgsProject.instance().addMapLayer(self.layer)
            logging.info(f'Camada {self.layer.name()} adicionada ao projeto.')
        except Exception as e:
            logging.error(f'Erro ao adicionar {self.ev_data.head()} à camada:\n {e}')

    def get_or_createBufferLayer(self):
        for layer in QgsProject.instance().mapLayers().values():
            if layer.name() == "Buffers":
                return layer
        buffer_layer = QgsVectorLayer(
            "Polygon?crs=EPSG:4326", "Buffers", "memory"
        )
        buffer_layer_provider = buffer_layer.dataProvider()
        buffer_layer_provider.addAttributes([
            QgsField("Event", QVariant.String)
        ])
        buffer_layer.updateFields()
        QgsProject.instance().addMapLayer(buffer_layer)
        return buffer_layer

    def repaintLayer(self):
        raio_graus = 20 / 111.32
        buffer_layer = self.get_or_createBufferLayer()
        buffer_layer_provider = buffer_layer.dataProvider()
        ev = self.eventSelector.currentText()
        try:
            categories = []
            circle_features = []
            ev_data = self.df[self.df['Event'] == ev].iloc[0]
            point = QgsPointXY(
                ev_data['Origem Longitude'],
                ev_data['Origem Latitude'])
            circle_geom = QgsGeometry.fromPointXY(point).buffer(raio_graus, 50)
            circle_feature = QgsFeature()
            circle_feature.setGeometry(circle_geom)
            circle_feature.setAttributes([ev_data['Event']])
            circle_features.append(circle_feature)
            rect = QgsRectangle(
                point.x() - raio_graus, point.y() - raio_graus,
                point.x() + raio_graus, point.y() + raio_graus
            )
            iface.mapCanvas().setExtent(rect)
            buffer_layer.startEditing()
            buffer_layer.deleteFeatures(
                [f.id() for f in buffer_layer.getFeatures()]
            )
            buffer_layer_provider.addFeatures(circle_features)
            buffer_layer.commitChanges()
            buffer_layer.updateExtents()
            line_symbol_layer = QgsLineSymbol.createSimple({
                'color': 'black',
                'width': '1'
            })
            polygon_symbol = QgsSymbol.defaultSymbol(
                buffer_layer.geometryType()
            )
            polygon_symbol.deleteSymbolLayer(0)
            polygon_symbol.appendSymbolLayer(line_symbol_layer)
            buffer_layer.setRenderer(QgsSingleSymbolRenderer(polygon_symbol))
            buffer_layer.triggerRepaint()
            QgsProject.instance().layerTreeRoot().findLayer(
                buffer_layer.id()
            ).setItemVisibilityChecked(True)
            iface.mapCanvas().refresh()
            renderer = QgsCategorizedSymbolRenderer("Event", categories)
            self.layer.setRenderer(renderer)
            self.layer.triggerRepaint()
            logging.info(f'Camada {self.layer.name()} redesenhada.')
        except Exception as e:
            if self.layer is None:
                logging.warning('Camada não definida.')
                return
            logging.error(e)

    def updateMseedAttributes(self):
        ev = self.eventSelector.currentText()
        net = self.networkSelector.currentText()
        sta = self.stationSelector.currentText()
        mseed = f'{net}_{sta}_{ev}'
        self.mseedText.setText(f'Arquivo: {mseed}')
        self.eventText.setText(f'Evento: {ev}')
        self.mseed_file_path = os.path.join(
            FILES_DIR, 'mseed', ev, f'{net}_{sta}_{ev}.mseed'
        )
        try:
            filtered_df = self.df[(self.df['Event'] == ev) & (self.df['Station'] == sta)]
            nb_picks = self.df[(self.df['Event'] == ev)].shape[0]
            if not filtered_df.empty:
                ev_prediction = filtered_df['Event Pred_final'].iloc[0]
                ev_prob_nat = filtered_df['Event Prob_Nat'].iloc[0]
                ev_predito = filtered_df['Event Pred_final'].iloc[0]
                distancia = filtered_df['Distance'].iloc[0]
                st_prediction = filtered_df['Pick Pred_final'].iloc[0]
                st_prob_nat = filtered_df['Pick Prob_Nat'].iloc[0]
                rotulo = filtered_df['Cat'].iloc[0]
            else:
                ev_prediction = 'Evento não encontrado ou sem predição'
                ev_prob_nat = 'N/A'
                ev_predito = 'N/A'
                distancia = 'N/A'
                st_prediction = 'N/A'
                st_prob_nat = 'N/A'
                rotulo = 'N/A'
            rotulo = filtered_df['Cat'].iloc[0] if not filtered_df.empty else 'N/A'
            ev_prob_nat = filtered_df['Event Prob_Nat'].iloc[0] if not filtered_df.empty else 'N/A'
            ev_predito = filtered_df['Event Pred_final'].iloc[0] if not filtered_df.empty else 'N/A'
            label = 'Natural' if rotulo == 'earthquake' else 'Anthropogenic'
        except Exception as e:
            logging.error(f'Erro ao atualizar atributos: {e}')
            return
        self.nb_picksText.setText(f'#Picks: {nb_picks}')
        if ev_prediction != label:
            self.ev_predText.setStyleSheet('font-weight: bold; color: red')
        else:
            self.ev_predText.setStyleSheet('color: black')
        self.ev_predText.setText(f'Predição: {ev_predito}')
        self.probNatText.setText(f'Prob. Natural: {ev_prob_nat}')
        self.stPredText.setText(f'Predição (pick): {st_prediction}')
        self.stProbText.setText(f'Prob. Natural (pick): {st_prob_nat}')
        if distancia != 'N/A':
            try:
                self.distanceText.setText(f'Distância: {distancia:.1f} km')
            except Exception as e:
                self.distanceText.setText(f'Distância:{e}')
        else:
            self.distanceText.setText(f'Distância: {distancia}')

    def loadSnuffler(self):
        try:
            if not os.path.isfile(self.mseed_file_path):
                raise FileNotFoundError
            subprocess.Popen(['.pyenv/versions/snuffler/bin/snuffler', self.mseed_file_path])
            print(f"Snuffler iniciado com {self.mseed_file_path}")
        except FileNotFoundError:
            print(f"Erro: Arquivo {self.mseed_file_path} não encontrado.")
        except Exception as e:
            print(f"Erro ao iniciar o Snuffler: {e}")

    def plot_waveform(self):
        fig, axs = plt.subplots(nrows=3, ncols=1, figsize=(6, 7))
        ev = self.eventSelector.currentText()
        net = self.networkSelector.currentText()
        sta = self.stationSelector.currentText()
        pick = self.ev_data[self.ev_data.Station == sta]
        logging.info(f"Pick {pick}")
        mseed = f'{net}_{sta}_{ev}'
        st = read(os.path.join(FILES_DIR, 'mseed', ev, f'{mseed}.mseed'))
        st.detrend('linear').taper(0.05).filter(
            'highpass',
            freq=2,
            corners=4,
            zerophase=True
        )
        logging.info(f'Stream carregada e Traço calculado {mseed}')
        pick_t = UTCDateTime(pick['Pick Time'].values[0])
        start_t = UTCDateTime(pick['Start Time'].values[0])
        p_start = pick_t - start_t
        n_start = p_start - 4.9
        colors = ['red', 'green', 'blue']
        line_width = 0.25
        # set ticks only at the bottom of the last axis, they share the same x-axis
        for i, tr in enumerate(st[:3]):
            t = np.arange(tr.stats.npts) * tr.stats.delta
            axs[i].plot(t, tr.data, c=colors[i % len(colors)], linewidth=line_width)
            axs[i].set_ylabel(f'Amplitude ({tr.stats.channel})')
            axs[i].axvspan(
                p_start, p_start + 3, alpha=0.25,
                label='S-Window', color='green'
            )
            axs[i].axvspan(
                n_start, n_start + 4, alpha=0.25,
                label='N-Window', color='red'
            )
            for spine in axs[i].spines.values():
                spine.set_visible(False)
            axs[i].spines['left'].set_visible(True)

        axs[-1].spines['bottom'].set_visible(True)
        axs[-1].set_xticks(np.arange(0, 60, 10))
        axs[-1].set_xticks(np.arange(0, 60, 5), minor=True)
        axs[-1].set_xlabel('Time [s]')
        handles, labels = axs[0].get_legend_handles_labels()
        plt.tight_layout()
        buf = io.BytesIO()
        plt.savefig(buf, format='png')
        plt.close()
        buf.seek(0)
        Img_waveform = Image.open(buf)
        return Img_waveform, pick

    def loadSpectre(self):
        try:
            if not os.path.isfile(self.mseed_file_path):
                raise FileNotFoundError
            ev = self.eventSelector.currentText()
            net = self.networkSelector.currentText()
            sta = self.stationSelector.currentText()
            self.ev_data = self.df[self.df.Event == ev]

            npy = f'{net}_{sta}_{ev}.npy'
            path = os.path.join(FILES_DIR, 'espectros', ev, npy)
            spectrogram = np.load(path, allow_pickle=True)
            spectrogram = np.moveaxis(spectrogram, 0, 2)

            freqs = list(range(1, 51))
            time = list(np.arange(0.5, 59.75, 0.25))
            psd_mat = np.array(spectrogram[:, :, 0])

            if psd_mat.shape != (len(time), len(freqs)):
                logging.error(f"Dimensões inválidas: {psd_mat.shape}")
                return

            psd_mat_normalized = (
                psd_mat - psd_mat.min()) / (psd_mat.max() - psd_mat.min())
            psd_mat_normalized = (psd_mat_normalized * 255).astype(np.uint8)

            cmap = plt.get_cmap('magma')
            color_img = cmap(psd_mat_normalized.T)
            color_img = (color_img[:, :, :3] * 255).astype(np.uint8)

            img_spectro = Image.fromarray(color_img)
            img_spectro = img_spectro.transpose(Image.FLIP_TOP_BOTTOM)
            try:
                img_waveform, pick = self.plot_waveform()
            except Exception as e:
                logging.error(f"img_waveform Error: {e}")
                return

            total_height = img_spectro.height + img_waveform.height
            combined_img = Image.new('RGB', (img_waveform.width, total_height))
            combined_img.paste(img_spectro, (0, 0))
            combined_img.paste(img_waveform, (0, img_spectro.height))

            draw = ImageDraw.Draw(combined_img)
            draw.text((255, 5), f'{ev}_{net}_{sta}', fill='white')
            prob = pick['Pick Prob_Nat'].values[0]
            prob_e = pick['Event Prob_Nat'].values[0]
            distance = pick['Distance'].values[0]
            snrp_q = pick['SNR_P_Q2'].values[0]
            snrp = pick['SNR_P'].values[0]
            snrp_std = pick['SNRP_std'].values[0]
            dist_std = pick['Distance_std'].values[0]
            pick_std = pick['Pick Prob_Nat_std'].values[0]
            cft_std = pick['CFT_std'].values[0]
            cft = pick['CFT'].values[0]
            draw.text((255, 20), f'Pick: {prob:.2f}/({pick_std:.2f})', fill='white')
            draw.text((395, 20), f'Event: {prob_e:.2f}', fill='white')
            draw.text((495, 20), f'CFT: {cft:.1f}/({cft_std:.1f})', fill='white')
            draw.text((255, 35), f'Distance: {distance:.0f} ({dist_std:.0f}) km', fill='white')
            draw.text((395, 35), f'SNR: {snrp:.1f}', fill='white')
            draw.text((495, 35), f'SNR Q2: {snrp_q:.1f}/({snrp_std:.1f})', fill='white')
            logging.info(f"Espectrograma iniciado com {path}")

            combined_img.save(f'{FIGURE_DIR}/espectros/{ev}_{net}_{sta}.png')
            combined_img.show()
            logging.info(f"Spectrogram iniciado com {path}")
        except Exception as e:
            logging.error(f"Erro ao iniciar o Espectrograma: {e}")
            if e == FileNotFoundError:
                logging.error(f"FileNootFoundError: {e}")

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def list_files(self, directory):
        return [
            f for f in os.listdir(directory)
            if os.path.isfile(
                os.path.join(directory, f)) and f.endswith('.csv')
        ]
